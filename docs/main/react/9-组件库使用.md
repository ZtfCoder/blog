---
title: react 组件库使用
description: react 组件库 antd
---

我们知道，像 `react` 和 `vue` 这种框架都是组件化开发。组件的意思是可以重复使用，减少重复开发。但是，如果一个项目从 0 开始全部实现一遍，需要开发特别多代码，而且很多组件没有任何重复开发的意义。例如，表格组件和弹窗组件，这些都是拥有极高重复性的组件。

在 `vue` 里的组件库代表是饿了么的 `element ui`。

在 `react` 里的组件库代表是阿里开发的 `antd`。

官方文档: [https://ant-design.antgroup.com/components/button-cn](https://ant-design.antgroup.com/components/button-cn)

组件库的用法本质上是大差不差的,vue 里,怎么样,react 里就怎么样

首先我们跟着文档进行一次安装,学会如何看文档也是一种技能

像这个页面,一般来说,我们首先是看这个页面,这个页面给我们描述了这个组件的特点,兼容性,以及,如何安装
[https://ant-design.antgroup.com/docs/react/introduce-cn](https://ant-design.antgroup.com/docs/react/introduce-cn)

来到这个安装的步骤[https://ant-design.antgroup.com/docs/react/introduce-cn#%E5%AE%89%E8%A3%85](https://ant-design.antgroup.com/docs/react/introduce-cn#%E5%AE%89%E8%A3%85)

让我们使用 `npm install antd --save`

我们在项目目录下执行这个命令

安装完后,我们可以在回到之前的 app.tsx

![alt text](./ts/image8.png)

我们在这里写`<Bu` 的时候,可以看到编辑器给了我们提示,可以看到这个名称是大写的,代表这个是一个组件,在 Button 最后,写着`antd` 表示这个`Button` 组件是 antd 组件库的,选中这个,回车 ,就会自动引入包,回到页面就可以看到我们的内容

```tsx
import { Button } from "antd";

function App() {
  return (
    <div>
      <Button>这是antd的按钮</Button>
    </div>
  );
}

export default App;
```

## 组件库文档

学组件库不在于需要把全部内容都学一遍,而是在于如何去查看官方文档

这个是按钮的文档
[https://ant-design.antgroup.com/components/button-cn](https://ant-design.antgroup.com/components/button-cn)

可以看到有非常多的样式可以供我们设置,
如果我们需要查看代码点击这个 即可
![alt text](./ts/image9.png)

可以看到文档是,可以通过设置 type 值,来改变按钮的样式,
![alt text](./ts/image10.png)

可以把按钮的官方给的几个案例都写下,主要是熟悉组件库的写法,

在最下面 有一个表格,这个表格给了按钮可以传入的 props 的值,以及他的作用,类型,以及默认值

![alt text](./ts/image11.png)

## 按钮loading
按钮组件里有一个`loading`,的 props,当`loading={true}` 的时候,按钮会出现转圈,这个可以用在用户提交信息的时候,防止用户重复点击

我们来简单模拟一个场景

```tsx
import { Button } from "antd";
import { useState } from "react";

function App() {
  const [value, setValue] = useState("");

  const submit = async () => {
    console.log(value);
  };

  return (
    <div>
      <div>
        <input type="text" onChange={(e) => setValue(e.target.value)} />
      </div>
      <div>
        <Button type="primary" onClick={submit}>
          提交数据
        </Button>
      </div>
    </div>
  );
}

export default App;
```

当我们在输入框输入完内容后,点击按钮,就会打印我们的 value 值,但是,这个按钮,我们可以无限次点击,`submit` 函数就会执行很多次,在实际开发中,我们会在`submit` 函数中调用接口,给后端发送数据,请求的时候,难免会存在网络延迟等情况,我们要避免这种用户重复提交的问题

为此,antd 的按钮就给了一个`loading`的 props 提供给我们

```tsx
import { Button } from "antd";
import { useState } from "react";

function App() {
  const [value, setValue] = useState("");
  // 创建一个loading的useState变量 // [!code focus]
  const [loading, setLoading] = useState(false); // [!code focus]

  const submit = async () => {
    //当用户点击后,设置loading为true // [!code focus]
    setLoading(true); // [!code focus]
    console.log(value);
  };

  return (
    <div>
      <div>
        <input type="text" onChange={(e) => setValue(e.target.value)} />
      </div>
      <div>
        <Button type="primary" loading={loading} onClick={submit}>// [!code focus]
        提交数据
        </Button>
      </div>
    </div>
  );
}

export default App;
```

当我们点击按钮后,按钮就不能再次点击了,就一直处于加载中,我们会在请求结束的时候,来使loading 为false 停止加载

这里由于我们没有安装`axios`,我们安装一次 在控制台打开,输入
```shell
npm i axios
```
安装好了后,我们在`submit` 函数里调用这里提前准备好的接口 这个接口的延迟有2s,2s后才会返回数据
https://apifoxmock.com/m1/5204577-4870723-default/loading


```tsx
import { Button } from 'antd'
import axios from 'axios'
import { useState } from 'react'

function App() {

  const [value,setValue] =  useState("")
  // 创建一个loading的useState变量
  const [loading,setLoading] =  useState(false)


  const submit = async () => {
    //当用户点击后,设置loading为true
    setLoading(true)
    // 在这里请求接口,注意这里{value} 是一个省略的语法 原样式是 {value:value} 当key和value的名称相同的时候可以省略value // [!code focus]
    const result = await axios.post("https://apifoxmock.com/m1/5204577-4870723-default/loading",{value})  // [!code focus]
    console.log(result.data) // [!code focus]
    //请求结束后,设置loading为false
    setLoading(false)  // [!code focus]
  }

  return (
    <div>
      <div><input type="text" onChange={e=>setValue(e.target.value)} /></div>
      <div>
        <Button type="primary" loading={loading} onClick={submit}>提交数据</Button>
      </div>
    </div>
  )
}

export default App

```

但是这样还不太好,万一,后端接口报错了怎么办,所以我们需要用try catch 来捕获异常,然后在final 再设置我们的`setLoading(false)`
```tsx
import { Button } from "antd";
import axios from "axios";
import { useState } from "react";

function App() {
  const [value, setValue] = useState("");
  // 创建一个loading的useState变量
  const [loading, setLoading] = useState(false);

  const submit = async () => {
    try {
      //当用户点击后,设置loading为true
      setLoading(true);
      const result = await axios.post(
        "https://apifoxmock.com/m1/5204577-4870723-default/loading",
        { value }
      );
      console.log(result.data);
      //请求结束后,设置loading为false
      setLoading(false);
    } catch (e) {
      console.log(e);
    } finally {
      //不管请求成功还是失败,最终都要设置loading为false
      setLoading(false)
    }
  };

  return (
    <div>
      <div>
        <input type="text" onChange={(e) => setValue(e.target.value)} />
      </div>
      <div>
        <Button type="primary" loading={loading} onClick={submit}>
          提交数据
        </Button>
      </div>
    </div>
  );
}

export default App;


```

记住我们需要在 finally 里最终保证我们的 loading 一定是可以恢复成false的即可


## AutoButton

讲到这里,我们可以顺便,可以再封装下这个按钮,

你可以看到,这里我们只有一个按钮,会提交数据,在真实项目里,存在大量的按钮会提交数据,如果是这样,那么,我们需要在每个接口请求的地方,都加上 上述的try catch

以及`setLoading(true);`和 `setLoading(false)` ,写1,2个还好,如果写大量这种重复的,就会感觉非常的繁琐,
因为这些loading 其实和我们业务没有关系,在`submit` 函数中,其实我们只是做了这么请求接口这么一件重要的事,其他的`setLoading` 都是有点多余,那么我们可以基于antd的按钮,封装一个可以用于请求接口后,就自动进入loading 状态,如果请求结束,那么就恢复


我们可以把 `setLoading(true);`和 `setLoading(false)` 放在一个通用的组件里

这个组件的名字我们叫`AutoButton` ,在项目根目录下的 `components` 文件夹里创建一个 `AutoButton` 的组件,注意,要先创建`AutoButton` 文件夹,然后再创建`index.tsx`

```tsx

import { Button } from "antd";
import { useState } from "react";

// 声明这个按钮组件的props 类型,方便使用者传入正确的类型
type AutoButtonProps = {
    // 这里表示 onClick 是一个可选的传入函数,所以,函数名称后面会跟上问号,
    //函数的返回值是一个  Promise ,这个的意思就是说 onClick 是一个异步函数, Promise<void> 表示这个异步的没有返回值
  onClick?: () => Promise<void>;
  // children 表示这个组件的内部的中间内容是 一个 react的节点类型,这个可以理解为jsx代码块, children 就是一个任意的 jsx 内容
  children: React.ReactNode;
};

const AutoButton = (props: AutoButtonProps) => {
  const { onClick, children } = props;
    // 创建一个loading 的变量
  const [loading, setLoading] = useState(false);

    // 按钮的点击事件
  const handleClick = async () => {
    try {
      setLoading(true); //设置按钮为加载中
      // 这里 我们使用await 语法,等待 外部传入的onClick 函数执行完毕,
      //这里由于,我们的onClick 是可选传入的参数,所以如果我们不传入的直接调用onClick() 就会出现错误,
      //为了避免这种情况,必须要加上 ? 问号,代表,如果onClick 存在,则执行onClick()
      await onClick?.();
    } catch (e) {
      console.log(e);
    } finally {
      setLoading(false);
    }
  };

    // 这里可以看到 其实children 就是我们之前写的按钮上面的文字,只不过,这个文字是一个jsx可以是任意的东西
  return (
    <Button onClick={handleClick} loading={loading}>
      {children}
    </Button>
  );
};

export default AutoButton;


```


在上面的代码中用到了一个可选的函数调用,在ts中,如果某个函数是可选的,如果你直接写`onClick()` ts是会给你报错了,因为,这个函数可能不存在,所以,对于不存在的函数,必须使用问号可选链的语法

问号可选链,其实是一个简写的语法,如果换成我们熟悉的if判断,则是以下代码

```ts
if(onClick){
  onClick()
}
```
问号语法函数调用等同于以上代码,当`onClick`存在,则调用`onClick()`


回到我们最开始的`app.tsx`文件,我们引入我们的`AutoButton` 组件,当前`AutoButton` 被点击的时候,触发一个`autoSubmit` 的函数去请求接口
```tsx
import { Button } from "antd";
import axios from "axios";
import { useState } from "react";
import AutoButton from "./components/AutoButton"; // [!code focus]

function App() {
  const [value, setValue] = useState("");
  // 创建一个loading的useState变量
  const [loading, setLoading] = useState(false);

  const submit = async () => {
    try {
      //当用户点击后,设置loading为true
      setLoading(true);
      const result = await axios.post(
        "https://apifoxmock.com/m1/5204577-4870723-default/loading",
        { value }
      );
      console.log(result.data);
      //请求结束后,设置loading为false
      setLoading(false);
    } catch (e) {
      console.log(e);
    } finally {
      //不管请求成功还是失败,最终都要设置loading为false
      setLoading(false)
    }
  };

  const autoSubmit = async () => {// [!code focus]
    // 这里我们没有做其他事情,只是把上面的请求接口代码复制了下来   // [!code focus]
    const result = await axios.post("https://apifoxmock.com/m1/5204577-4870723-default/loading",{ value }); // [!code focus]
    console.log(result.data); // [!code focus]
  } // [!code focus]

  return (
    <div>
      <div>
        <input type="text" onChange={(e) => setValue(e.target.value)} />
      </div>
      <div>
        <Button type="primary" loading={loading} onClick={submit}>
          提交数据
        </Button>
        <AutoButton  onClick={autoSubmit}> // [!code focus]
          提交数据 // [!code focus]
        </AutoButton> // [!code focus]
      </div>
    </div>
  );
}

export default App;


```

可以看到,我们的我们的 `AutoButton` 的`onClick` 事件,只关心数据请求,并不关心是否`loading`,因为loading的状态全部都在 `AutoButton` 这个组件内部,这样一来,我们可以把`Button`
全部替换成我们组件封装的`AutoButton`

## message组件

官方文档
[https://ant-design.antgroup.com/components/message-cn](https://ant-design.antgroup.com/components/message-cn)

message 主要是用来提示信息,可以弹出一些提示,例如用户提交数据成功后,可以提示下`请求成功`

文档推荐使用 ` const [messageApi, contextHolder] = message.useMessage();`
这种方式,但是我们一般为了图方便都是使用 静态的方法,`https://ant-design.antgroup.com/components/message-cn#api`
例如`message.success()`  `message.error` `message.info` 等等

我们可以在上面的代码基础上添加 这种静态的方法调用,
```tsx
import { Button, message } from "antd"; // [!code focus]
import axios from "axios";
import { useState } from "react";
import AutoButton from "./components/AutoButton";

function App() {
  const [value, setValue] = useState("");
  // 创建一个loading的useState变量
  const [loading, setLoading] = useState(false);

  const submit = async () => {
    try {
      //当用户点击后,设置loading为true
      setLoading(true);
      const result = await axios.post(
        "https://apifoxmock.com/m1/5204577-4870723-default/loading",
        { value }
      );
      console.log(result.data);
      //请求结束后,设置loading为false
      setLoading(false);
    } catch (e) {
      console.log(e);
    } finally {
      //不管请求成功还是失败,最终都要设置loading为false
      setLoading(false)
    }
  };

  const autoSubmit = async () => {
    const result = await axios.post(
      "https://apifoxmock.com/m1/5204577-4870723-default/loading",
      { value }
    );
    console.log(result.data);
    message.success("提交成功"); // [!code focus]
  }

  return (
    <div>
      <div>
        <input type="text" onChange={(e) => setValue(e.target.value)} />
      </div>
      <div>
        <Button type="primary" loading={loading} onClick={submit}>
          提交数据
        </Button>
        <AutoButton  onClick={autoSubmit}>
          提交数据
        </AutoButton>
      </div>
    </div>
  );
}

export default App;


```



## 表格的使用



## modal 弹窗


## 表单 组件
